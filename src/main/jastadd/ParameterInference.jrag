import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;

aspect InferParameter{
    /**
        * Saves response data names generated by random requests.
        * <p>This is an auxiliary method to distinguish saved dictionary values.</p>
        * <p>(Future work: translate this to Map or Tuple).</p>
        * @return first String part divided by <code>?</code>.
        */
    syn String ParameterObject.getParameterName(String parameter) = parameter.substring(0, parameter.indexOf("?"));

    /**
    * Saves response data values generated by random requests.
    * <p>This is an auxiliary method to distinguish saved dictionary values.</p>
    * <p>(Future work: translate this to Map or Tuple).</p>
    * @return second String part divided by <code>?</code>.
    */
    syn String ParameterObject.getParameterValue(String parameter) = parameter.substring(parameter.indexOf("?") + 1);

    /**
      * Checks if a path has the request types <code>GET</code> and/or <code>POST</code>, and calls <code>inferUrl(String pathRef,OperationObject operationObject, List<String> dict)</code>.
      * <p>Afterwards, inferred URLs are saved in a list.</p>
      * @return The list of String representing the inferred URLs.
      */
    inh List<String> PathsObject.inferUrl(List<String> parameters);
    eq OpenAPIObject.getPaths().inferUrl(List<String> parameters){
      List<String> urls = new ArrayList<>();
      JastAddList<PathItemTuple> pathItemTuples = getPaths().getPathsList();
      String uri = getServers(0).getUrl();

      for (PathItemTuple pathItemTuple : pathItemTuples) {
        PathItemObject pathItemObject = pathItemTuple.getPathItem().pathItemObject();

        if (pathItemObject.hasGetOperation())
          urls.addAll(pathItemObject.getGetOperation().generateUrls(uri + pathItemTuple.getKey(), parameters));
      }

      return urls;
    }

    /**
      * Checks which parameter types the targeted GET request has (Path or Query) and calls corresponding parameter inferrer.
      * <p>Afterwards, inferred parameters are written in the url.</p>
      * @return An URL with the inferred parameters in String.
      */
    syn List<String> OperationObject.generateUrls(String url, List<String> parameters){
      List<String> newUrls = new ArrayList<>();

      for (ParameterType parameterType : getParametersList()) {
        ParameterObject parameterObject = parameterType.parameterObject();
        SchemaObject schemaObject = parameterObject.getSchema().schemaObject();

        switch (parameterObject.getIn()) {
          case "path":
            newUrls = parameterObject.addPathParametersToUrl(url, parameters);
            break;
          case "query":
            newUrls = parameterObject.addQueryParametersToUrl(url, parameters);
        }
      }

      return newUrls;
    }

    /**
      * Checks if there are Path parameters that are saved in the dictionary and might be usable.
      * <p>Search is provided by schema names and Case-Insensitivity./p>
      * @return The list of Urls with the added Url from the dicitionary.
      */
    syn List<String> ParameterObject.addPathParametersToUrl(String url, List<String> parameters){
      List<String> newUrls = new ArrayList<>();

      for (String parameter : parameters) {
        String path = url.substring(url.indexOf("{"), url.indexOf("}") + 1);
        if (getName().equalsIgnoreCase(path.substring(0, parameter.indexOf("?"))))
          newUrls = root().addValueToList(newUrls, url.replace(path, url.substring(url.indexOf("?") + 1)));
      }

      return newUrls;
    }

    /**
      * Checks if there are Query parameters that are saved in the dictionary and might be usable.
      * <p>Search is provided by schema names and Case-Insensitivity./p>
      * @return The list of Urls with the added Url from the dicitionary.
      */
    syn List<String> ParameterObject.addQueryParametersToUrl(String url, List<String> parameters){
      List<String> newUrls = new ArrayList<>();
      SchemaObject schemaObject = getSchema().schemaObject();

      if (schemaObject.getType().equals("array")) {
        for (String parameter : parameters) {
          if (getName().equalsIgnoreCase(getParameterName(parameter))
                  && !url.contains(String.format("%s=%s", getName(), getParameterValue(parameter))))
            url += String.format("%s=%s", getName(), getParameterValue(parameter));
        }
        newUrls = root().addValueToList(newUrls, url.replaceFirst("&", "?"));
      } else {
        for (String parameter : parameters) {
          if (getName().equalsIgnoreCase(getParameterName(parameter)))
            newUrls = root().addValueToList(newUrls, String.format("%s?%s=%s", url, getName(),
                    getParameterValue(parameter)));
        }
      }

      return newUrls;
    }

    /**
      * Saves single response JSON data into the dictionary.
      * @return The list of response data (dictionary).
      */
    public List<String> OperationObject.addParameterToDictionary(SchemaType schema,String responseText, List<String> dictionary) throws Exception{
      ObjectMapper mapper = new ObjectMapper();
      List<String> newDictionary = new ArrayList<>(dictionary);
      JsonNode responseNode = mapper.readTree(responseText);

      if (schema instanceof SchemaReference) processSchemaReference(schema, responseNode, dictionary);
      else processSchemaObject(schema, responseNode, dictionary);

      return newDictionary;
    }

    /**
      * Saves array response JSON data into the dictionary.
      * @return The list of response data (dictionary).
      */
    public List<String> OperationObject.addParametersToDictionary(SchemaType schema,String responseText, List<String> dictionary) throws Exception{
      ObjectMapper mapper = new ObjectMapper();
      ArrayNode responseNode = ((ArrayNode) mapper.readTree(responseText));
      Iterator<JsonNode> props = responseNode.elements();

      while (props.hasNext())
        dictionary = addParameterToDictionary(schema.schemaObject().getItemsSchema().getSchema(), props.next().toString(), dictionary);
      return dictionary;
    }

    private void OperationObject.processSchemaObject(SchemaType schema, JsonNode responseNode, List<String> dictionary) {
      for (PropertyItem p : schema.schemaObject().getPropertyItemsList()) {
        String value = parseValue(responseNode, p.getName());
        dictionary.add(p.getName() + "?" + value);
      }
    }

    private void OperationObject.processSchemaReference(SchemaType schema, JsonNode responseNode, List<String> dictionary) {
      SchemaReference schemaReference = (SchemaReference) schema;
      String referencePrefix = extractReferencePrefix(schemaReference);

      for (PropertyItem propertyItem : schema.schemaObject().getPropertyItemsList()) {
        String fullName = referencePrefix + propertyItem.getName();
        String value = parseValue(responseNode, propertyItem.getName());

        dictionary.add(fullName + "?" + value);
        dictionary.add(propertyItem.getName() + "?" + value);
      }
    }

    private String OperationObject.extractReferencePrefix(SchemaReference schemaRef) {
      String reference = schemaRef.getRef();
      return reference.substring(reference.lastIndexOf("/") + 1);
    }

    private String OperationObject.parseValue(JsonNode responseNode, String key) {
      if (!responseNode.has(key) || responseNode.get(key).isNull()) return "";

      JsonNode node = responseNode.get(key);
      return node.asText();
    }

    public List<String> OpenAPIObject.addValueToList(List<String> list, String value) {
      List<String> newList = new ArrayList<>(list);
      if (!newList.contains(value)) {
        newList.add(value);
      }
      return newList;
    }
}